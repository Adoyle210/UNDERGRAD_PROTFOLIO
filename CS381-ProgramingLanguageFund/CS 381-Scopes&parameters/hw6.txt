CS 381: Homework 6
By  Alexis Doyle & Yu Wei Koh 

--------------------------------------------------------------------------------------------------------
Problem 1: Runtime Stack
Consider the following block. Assume static scoping and call-by-value parameter passing.
1: {    int x;
2:    int z;
3:    z := 1;
4:    { int f(int x){ 
5:        if x = 0 then {
6:            z := 1 }
7:        else {
8:            z := f(x-1) * z+1};
9:        return z;
10:      };
11:      x := f(2);
12:    };
13: }
Demonstrate the computations that take place during the evaluation of this block, that is, give a
sequence of lines each showing the complete runtime stack with all activation records after each
statement or function call. For recursive calls use one stack onto which a new activation record is
pushed on for each recursive function call.

Answer: 
the scope:
[]                                                              nothing 
[(x:?)]                                                         pushing x
[(z:?),(x:?)]                                                   pushing z
[(z:1),(x:?)]                                                   setting z = 1 from z = ?
[f{},(z:1),(x:?)]                                               pushing f function
[(x'f(2):2), f{},(z:1),(x:?)]                                   calling f(2) 
[(x''f(1):1),(x'f(2):2), f{},(z:1),(x:?)]                       recursuive call from f(2) into f(1)
[(x'''f(0):0),(x''f(1):1),(x'f(2):2), f{},(z:1),(x:?)]          recursuive call from f(2) from f(1) into f(0)
[(x'''f(0):0),(x''f(1):1),(x'f(2):2), f{},(z:1),(x:?)]          recursuive call of f(0) sets z to 1
[(x''f(1):1),(x'f(2):2), f{},(z:1),(x:?)]                       returns f(1) sets y = f(0) * 1 + 1 = 2 
[(x'f(2):2), f{},(z:1),(x:?)]                                   returns f(2) sets y = f(1) * 1 + 1 = 3
[f{},(z:1),(x:3)]                                               return from f(2) and sets x as the return value of 3

alternative break down of calling f(2): 
x != 0 so z := f(x-1) * z+1 (line 8)
    = f(2-1) * z+1      (this is f(1))
    = f(1-1) * z+1      (this is f(0))
    f(0) so z = 1 is returning 

    = f(0) * z+1    ->     1 * 1 + 1 = 2
    = f(1) * z+1    ->     2 * 1 + 1 = 3
    so x = 3

--------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------
Problem 2: Static and Dynamic Scope
Consider the following block. Assume call-by-value parameter passing.
1: {   int x;
2:    int y;
3:    int z;
4:    x := 3;
5:    y := 7;
6:    {   int f(int y) {return x * y };
7:        int y;
8:       y := 11;
9:        { int g(int x) {return f(y) };
10:            {   int y;
11:                y := 13;
12:                z := g(2);
13:            };
14:        };
15:    };
16: }

a) Draw the runtime stack after each line executes under static scoping. What value assigned to z in line 12?
b) Draw the runtime stack after each line executes under dynamic scoping. What value assigned to z in line 12?

The scope:                                                            Stack View:      
[]                                                                      nothing
[(x:?)]                                                                 pushing x 
[(y:?),(x:?)]                                                           pushing y 
[(z:?),(y:?),(x:?)]                                                     pushing z 
[(z:?),(y:?),(x:3)]                                                     setting x = 3 from x = ?
[(z:?),(y:7),(x:3)]                                                     setting y = 7 from y = ? 
[f{},(z:?),(y:7),(x:3)]                                                 pushing f function
[(y':?),f{},(z:?),(y:7),(x:3)]                                          pushing y' (new scope y) 
[(y':11),f{},(z:?),(y:7),(x:3)]                                         setting y' = 11 from y' = ?
[g{},(y':11),f{},(z:?),(y:7),(x:3)]                                     pushing g function
[(y'':?),g{},(y':11),f{},(z:?),(y:7),(x:3)]                             setting y'' (another new scope y) 
[(y'':13),g{},(y':11),f{},(z:?),(y:7),(x:3)]                            setting y'' = 13 from y'' = ?
[(x'g(2):2),(y'':13),g{},(y':11),f{},(z:?),(y:7),(x:3)]                 calling g(2), pushing x from scope g(2)
[(y'f(13):13),(x'g(2):2),(y'':13),g{},(y':11),f{},(z:?),(y:7),(x:3)]    calling f(13) pushing y from scope f(13)
[(y'':13),g{},(y':11),f{},(z:?),(y:7),(x:3)]                            return from g(2){f(13){ return ...}} and set z = ? to z = (static: 10) (dynammic: 15)

Answer A:
static scoping z = 3 * 7 = 21

Answer B:
dynamic scoping y = 2 * 13 = 26

--------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------
Problem 3: Parameter Passing 
Consider the following block. Assume dynamic scoping.
1; {   int y;
2:    int z;
3:   y := 7;
4:    {   int f(int a){
5:            y := a + 1;
6:            return (y+a)
7:        };
8:        int g(int x){
9:            y := f(x+1)+1;
10:            z := f(x-y+3);
11:            return (z+1)
12:        }
13:        z := g(y*2);
14:    };
15: }

a) Draw the runtime stack after each line executes given that both parameters a and x are passed
using Call-by-Name. What are the values of y and z after line 13 executes?

b) Draw the runtime stack after each line executes given that both parameters a and x are passed
using Call-by-Need. What are the values of y and z after line 13 executes?

Answer A:
the scope:
[]                                                            nothing
[(y:?)]                                                       pushing y
[(z:?),(y:?)]                                                 pushing z
[(z:?),(y:7)]                                                 set y to 7 from ?
[f{},(z:?),(y:7)]                                             pushing function f
[g{},f{},(z:?),(y:7)]                                         pushing function g
[g{},f{},(z:g(y+2)),(y:7)]                  
[(x'g(y*2):y*2), g{},f{},(z:g(y*2)),(y:7)]                    calling g and here x = 14
[(y': f(x+1)+1),(x'g(14):z+1), g{},f{},(z:g(14)),(y:7)]         new scope which is 'y = 30 and x is 32 now 
[(z':f(x-y+3)),(y': 30),(x'g(14):z+1), g{},f{},(z:g(14)),(y:7)] new scope z and x is 32 and 'y is 48 now
[g{},f{},(z:-18),(y:7)]                                       return g(14) z = 12

so Z = - 40 and y = 7

break down:
z = g(7+2) -> g(14) (line 13)
(in function g: )
x = y + 2 
'y = f(15)+1 -> 29 + 1 -> 30
x now == 32
z = f(x - 'y + 3) -> 'y is now 48 -> f(32 - 30 + 3) =  f(5) = 11
return 11 + 1 -> z = 12


Answer B:
The scope:
[]                                                        nothing
[(y:?)]                                                   pushing y
[(z:?),(y:?)]                                             pushing z
[(z:?),(y:7)]                                             set y to 7 from ?
[f{},(z:?),(y:7)]                                         pushing function f
[g{},f{},(z:?),(y:7)]                                     pushing function g
[g{},f{},(z:g(y*2)),(y:7)]                  
[(x'g(14):14), g{},f{},(z:g(14)),(y:7)]                   calling g 
[(y': 32),(x'g(14):14), g{},f{},(z:g(14)),(y:7)]            new scope y = 32
[(z':-29),(y': 32),(x'g(14):14), g{},f{},(z:g(14)),(y:7)]    new scope z = -19
[g{},f{},(z:-28),(y:7)]                                   return g(9) andset z to -28

so z = -28 and y = 7

break down:
z = g(7*2) -> g(14) (line 13)

(in function g: )
y = f(15)+1 -> 31 + 1 -> 32
z = f(14 -32 + 3) -> f(-15) -> -29
return -29 + 1 -> z = -28 

--------------------------------------------------------------------------------------------------------



